package r01f.securitycontext;

import java.util.Date;

import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;
import r01f.guids.CommonOIDs.AppCode;
import r01f.guids.CommonOIDs.TenantID;
import r01f.objectstreamer.annotations.MarshallField;
import r01f.objectstreamer.annotations.MarshallField.MarshallFieldAsXml;
import r01f.securitycontext.SecurityIDS.LoginID;
import r01f.securitycontext.SecurityIDS.SecurityProviderID;
import r01f.securitycontext.SecurityIDS.SecurityToken;
import r01f.securitycontext.SecurityOIDs.UserOID;
import r01f.types.url.Url;

/**
 * R01M API {@link SecurityContext} implementation
 */
@Accessors(prefix="_")
public abstract class SecurityContextBase 
           implements SecurityContext {

	private static final long serialVersionUID = 6313898883935383799L;
/////////////////////////////////////////////////////////////////////////////////////////
//  FIELDS
/////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Tenant id (tenatA, tenantB, ...)
	 * Allows the database and file system data to be partitioned by this value
	 */
	@MarshallField(as="tenantId",
				   whenXml=@MarshallFieldAsXml(attr=true))
	@Getter @Setter protected TenantID _tenantId; 	// TODO the tenant id should come with the authentication data (ie xlnets)
	/**
	 * The date this user context was created
	 */
	@MarshallField(as="createDate",
				   whenXml=@MarshallFieldAsXml(attr=true))	
	@Getter @Setter protected Date _createDate;
	/**
	 * The [security provider] id used to creat this context
	 */
	@MarshallField(as="securityProviderId",
				   whenXml=@MarshallFieldAsXml(attr=true))	
	@Getter @Setter protected SecurityProviderID _securityProviderId;
	/**
	 * The authenticated actor 
	 */
	@MarshallField(as="authActor",
				   whenXml=@MarshallFieldAsXml(attr=true))
	@Getter @Setter protected SecurityContextAuthenticatedActor _authenticatedActor;
	/**
	 * A security token (a jwt, some signed token, etc)
	 * Usually this is used at MASTER security contexts that SHOULD ONLY be created by a legitimated system
	 * (NOT anyone can generate a MASTER security context)
	 * ... in order to ensure that this security context is a legitimate one, the provider that
	 * 	   generates it, signs a token with a private key that only that legitimate provider knows
	 * ... when the token is validated, the signed token can be checked to ensure it was generated by a 
	 *     legitimate system
	 */
	@MarshallField(as="securityToken",escape=true)
	@Getter @Setter protected SecurityToken _securityToken;
	/**
	 * True if this token is for a SYSTEN user (a system internal one with all privileges)
	 * Usually, when true, a [token] is provided 
	 */
	@MarshallField(as="systemUser",
				   whenXml=@MarshallFieldAsXml(attr=true))	
	@Getter @Setter protected boolean _systemUser;
	/**
	 * The login page url
	 */
	@MarshallField(as="loginUrl")
	@Getter @Setter protected Url _loginUrl;
/////////////////////////////////////////////////////////////////////////////////////////
//  CONSTRUCTOR
/////////////////////////////////////////////////////////////////////////////////////////
	protected SecurityContextBase() {
		_createDate = new Date();
	}
////////// Auth actor
	public SecurityContextBase(final SecurityContextAuthenticatedActor authActor) {
		this(authActor,
			 TenantID.DEFAULT);
	}
	public SecurityContextBase(final SecurityContextAuthenticatedActor authActor,
						   	   final TenantID tenantId) {
		this(authActor,
			 null,	// no token 
			 tenantId);
	}
	public SecurityContextBase(final SecurityContextAuthenticatedActor authActor,
							   final SecurityToken securityToken) {
		this(authActor,
			 securityToken,
			 TenantID.DEFAULT);
	}
	public SecurityContextBase(final SecurityContextAuthenticatedActor authActor,
							   final SecurityToken securityToken,
							   final TenantID tenantId) {
		_createDate = new Date();
		_authenticatedActor = authActor;
		_tenantId = tenantId;
		_securityToken = securityToken;
	}
////////// App login
	public SecurityContextBase(final AppCode appCode) {
		this(SecurityContextAuthenticatedActor.forAppLogin(appCode));
	}
	public SecurityContextBase(final AppCode appCode,
						   	   final TenantID tenantId) {
		this(SecurityContextAuthenticatedActor.forAppLogin(appCode),
			 tenantId);
	}
	public SecurityContextBase(final AppCode appCode,
							   final SecurityToken securityToken) {
		this(SecurityContextAuthenticatedActor.forAppLogin(appCode),
			 securityToken);
	}
////////// User login
	public SecurityContextBase(final SecurityProviderID securityProviderId,final LoginID loginId,
							   final UserOID userOid) {
		this(SecurityContextAuthenticatedActor.forUserLogin(securityProviderId,loginId,
															userOid));
	}
	public SecurityContextBase(final SecurityProviderID securityProviderId,final LoginID loginId,
							   final UserOID userOid,
							   final SecurityToken securityToken) {
		this(SecurityContextAuthenticatedActor.forUserLogin(securityProviderId,loginId,
															userOid),
			 securityToken);
	}
	public SecurityContextBase(final SecurityProviderID securityProviderId,final LoginID loginId,
							   final UserOID userOid,
						   	   final TenantID tenantId) {
		this(SecurityContextAuthenticatedActor.forUserLogin(securityProviderId,loginId,
															userOid),
			 tenantId);
	}
////////// Security token
	public SecurityContextBase(final SecurityToken securityToken) {
		this(securityToken,
			 TenantID.DEFAULT);
	}
	public SecurityContextBase(final SecurityToken securityToken,
							   final TenantID tenantId) {
		this();
		_securityToken = securityToken;
		_tenantId = tenantId;
		_createDate = new Date();
	}
/////////////////////////////////////////////////////////////////////////////////////////
//  METHODS
/////////////////////////////////////////////////////////////////////////////////////////
	@Override
	public SecurityProviderID getSecurityProviderId() {
		return _authenticatedActor.getSecurityProviderId();
	}
	@Override
	public LoginID getLoginId() {
		return _authenticatedActor.getLoginId();
	}
/////////////////////////////////////////////////////////////////////////////////////////
//	APP
/////////////////////////////////////////////////////////////////////////////////////////
	@Override
	public SecurityContextForApp asForApp() {
		if (!this.isForApp()) throw new IllegalStateException("The [security context] is a USER [security context], NOT an APP one!");
		return new SecurityContextForApp() {
						@Override
						public AppCode getAppCode() {
							LoginID loginId = _authenticatedActor.getLoginId();
							return AppCode.forLogin(loginId);
						}
			   };
	}
	@Override
	public boolean isForApp() {
		return _authenticatedActor.isApp();
	}
/////////////////////////////////////////////////////////////////////////////////////////
//	USER
/////////////////////////////////////////////////////////////////////////////////////////	
	@Override
	public SecurityContextForUser asForUser() {
		if (!this.isForUser()) throw new IllegalStateException("The [security context] is an APP [security context], NOT a USER one!");
		return new SecurityContextForUser() {
						@Override
						public UserOID getUserOid() {
							UserOID userOid = _authenticatedActor.getUserOid();
							return userOid;
						}
			   };
	}
	@Override
	public boolean isForUser() {
		return _authenticatedActor.isUser();	
	}
/////////////////////////////////////////////////////////////////////////////////////////
//  
/////////////////////////////////////////////////////////////////////////////////////////
	@Override @SuppressWarnings("unchecked")
	public <CTX extends SecurityContext> CTX as(final Class<CTX> type) {
		return (CTX)this;
	}
}
